import { Tab, Tabs, Callout } from 'nextra-theme-docs'

# Build a custom auction component

This tutorial will walk you through building a custom auction component for your Nouns Builder DAO. This is a React specific tutorial that leverages [Next.js](https://nextjs.org/) (Next) and its [App Router](https://nextjs.org/docs/app). The implementation of this tutorial leverages [Tailwind CSS](https://tailwindcss.com/) for styling, but the code snippets provided below are unstyled. Any styling approach will work just fine.

### Create a new project and install dependencies

In a new directory, use the `create-wagmi` CLI tool to spin up a Next project configured with [wagmi](https://wagmi.sh/). We'll use a template preloaded with [ConnectKit](https://docs.family.co/connectkit).

{/* prettier-ignore-start */}
<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tab>
```bash
pnpm create wagmi --template next-connectkit
```
  </Tab>
  <Tab>
```bash
npm init wagmi --template next-connectkit
```
  </Tab>
  <Tab>
```bash
yarn create wagmi --template next-connectkit
```
  </Tab>
</Tabs>
{/* prettier-ignore-end */}

Follow the command line prompts. If you don't have an Alchemy/Infura API key or WalletConnect ID handy, you can always provide it manually later on.

Install the builder utils package and its peer dependencies listed below.

{/* prettier-ignore-start */}
<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tab>
```bash
pnpm add @public-assembly/builder-utils
```
  </Tab>
  <Tab>
```bash
npm install @public-assembly/builder-utils
```
  </Tab>
  <Tab>
```bash
yarn add @public-assembly/builder-utils
```
  </Tab>
</Tabs>
{/* prettier-ignore-end */}

```json
 "peerDependencies": {
    "date-fns": "^2.29.3",
    "graphql": "^16.6.0",
    "graphql-request": "^5.0.0",
    "graphql-tag": "^2.12.6",
    "swr": "^1.3.0",
  },
```

### Clean up your project

For the sake of this tutorial, you won't need any of the hooks or components that arrive with wagmi's template. Besides the `ConnectButton`, you can delete all of the components and functions inside each of these folders. Then make sure to visit the `page.tsx` component inside your `app` directory and remove the unsued imports and rendering instances.

```jsx
import { ConnectButton } from '../components/ConnectButton'

export function Page() {
  return <ConnectButton />
}

export default Page
```

### Configure the provider components

Builder utils provides a collection of provider components used to dynamically pass contract specific data throughout your application. Begin configuring these provider components by first navigating to your `app` directory and then to the `providers.tsx` component.

Import the `ManagerProvider` component from builder utils and nest it beneath the wallet connection provider. This component accepts your DAO's token contract address as a prop. For this tutorial we'll use Public Assembly's. You can find this address for your DAO by navigating to the 'Smart Contract' tab beneath the artwork for your DAO on [Nouns Builder](https://nouns.build/).

```jsx
'use client'

import { ConnectKitProvider } from 'connectkit'
import * as React from 'react'
import { WagmiConfig } from 'wagmi'
import { config } from '../wagmi'
import { ManagerProvider } from '@public-assembly/builder-utils'

export function Providers({ children }: { children: React.ReactNode }) {
  const [mounted, setMounted] = React.useState(false)
  React.useEffect(() => setMounted(true), [])
  return (
    <WagmiConfig config={config}>
      <ConnectKitProvider>
        <ManagerProvider tokenAddress='0xd2e7684cf3e2511cc3b4538bb2885dc206583076'>
          {mounted && children}
        </ManagerProvider>
      </ConnectKitProvider>
    </WagmiConfig>
  )
}
```

### Create a skeleton component

In your `components` directory create a component called `AuctionSkeleton.tsx`. This component will exist as a layout component that dynamically switches between the current auction and historical auctions while rendering the respective interface elements.

This component leverages the [`useTokenExplorer`](pages/hooks/useTokenExplorer.mdx) hook which returns two functions each responsible for navigating between past tokens and the current auction.

```jsx
import { useTokenExplorer } from '@public-assembly/builder-utils'

export function AuctionSkeleton() {
  const { incrementId, decrementId } = useTokenExplorer()

  return (
    <>
      <button onClick={decrementId}>Backward</button>
      <button onClick={incrementId}>Forward</button>
    </>
  )
}
```

Additionally you'll want to grab two more of the destructured elements returned by the useTokenExplorer hook, boolean elements that will allow you to disable your buttons if the user has reached the first or last (current) token.

```jsx
export function AuctionSkeleton() {
  const { incrementId, decrementId, isFirstToken, isLastToken } = useTokenExplorer()

  return (
    <>
      <button disabled={isFirstToken} onClick={decrementId}>
        Backward
      </button>
      <button disabled={isLastToken} onClick={incrementId}>
        Forward
      </button>
    </>
  )
}
```

Next we'll create another component called `CurrentAuction.tsx` which will render all the data associated with the current auction.

This component leverages the [`useTokenMetadata`](pages/hooks/useTokenMetadata.mdx) hook which accepts a string representing the token id to render and returns the name and artwork for that token.

Note that the `tokenId` passed into `useTokenMetadata` is in the form of a number, but must be convereted into a string in order to be properly formatted for the underlying API call.

```jsx
import { useTokenMetadata, useTokenExplorer } from '@public-assembly/builder-utils'

export function CurrentAuction({ tokenId }: { tokenId: number }) {
  const { tokenName, tokenThumbnail } = useTokenMetadata(String(tokenId))

  return <></>
}
```

We'll flesh out the `CurrentAuction` component a bit more by adding an img tag and rendering the artwork alongside the token name. If you're interested in using Next's native Image component, be sure to read the documentation [here](https://nextjs.org/docs/pages/api-reference/components/image).

```jsx
import { useTokenMetadata, useAuctionState } from '@public-assembly/builder-utils'

export function CurrentAuction() {
  const { auctionState } = useAuctionState()
  const { tokenName, tokenThumbnail } = useTokenMetadata(String(auctionState?.tokenId))

  return (
    <>
      <h1>{tokenName}</h1>
      <img src={tokenThumbnail} />
    </>
  )
}
```

Next we'll create a `HistoricalAuction` component. Similarly to the `CurrentAuction` component, this component will utilize the `useTokenMetadata` hook, but instead of grabbing the tokenId from the `auctionState` object, this component will accept `tokenId` as a prop.

```jsx
import { useTokenMetadata } from '@public-assembly/builder-utils'

export function HistoricalAuction({ tokenId }: { tokenId: number }) {
  const { tokenName, tokenThumbnail } = useTokenMetadata(String(tokenId))

  return (
    <>
      <h1>{tokenName}</h1>
      <img src={tokenThumbnail} />
    </>
  )
}
```

Lets return to our `AuctionSkeleton` component and setup conditional rendering based on whether or not the state of the token id object reflects the current auction.

We'll create an arrow function called `renderContent` that checks if the `isLastToken` boolean is true. If so it will return the `CurrentAuction` component, if not it will render the `HistoricalAuction` component. Additionally we can use the `isLastToken` boolean alongisde the `isFirstToken` boolean to create disabled states for our explorer buttons.

```jsx
import { useTokenExplorer } from '@public-assembly/builder-utils'
import { CurrentAuction } from './CurrentAuction'
import { HistoricalAuction } from './HistoricalAuction'

export function AuctionSkeleton() {
  const { currentTokenId, incrementId, decrementId, isFirstToken, isLastToken } =
    useTokenExplorer()

  const renderContent = () => {
    if (isLastToken) {
      return <CurrentAuction />
    } else {
      return <HistoricalAuction tokenId={currentTokenId} />
    }
  }

  return (
    <>
      {renderContent()}
      <>
        <button disabled={isFirstToken} onClick={decrementId}>
          Backward
        </button>
        <button disabled={isLastToken} onClick={incrementId}>
          Forward
        </button>
      </>
    </>
  )
}
```

### Add bidding functionality

We'll start by adding a `hooks` folder to our `src` directory. This will house the contract interaction scaffolding we've prepared with wagmi. Create a new hook called `useCreateBid` and add the following code.

```jsx
import { useContractWrite, usePrepareContractWrite, useWaitForTransaction } from 'wagmi'
import { Hex } from 'viem'
import {
  useManagerContext,
  auctionAbi,
  useAuctionState,
} from '@public-assembly/builder-utils'

export function useCreateBid({ bidAmount }: { bidAmount: string }) {
  const { auctionAddress } = useManagerContext()
  const { auctionState } = useAuctionState()

  const { config: createBidConfig } = usePrepareContractWrite({
    address: auctionAddress as Hex,
    abi: auctionAbi,
    functionName: 'createBid',
    args: [BigInt(auctionState?.tokenId as number)],
    value: BigInt(bidAmount),
  })

  const {
    data: createBidData,
    write: createBid,
    isError: createBidError,
  } = useContractWrite(createBidConfig)
  const {
    data: createBidTx,
    isLoading: createBidLoading,
    isSuccess: createBidSuccess,
  } = useWaitForTransaction({
    hash: createBidData?.hash,
  })

  return {
    createBid,
    createBidSuccess,
    createBidError,
    createBidLoading,
    createBidTx,
  }
}
```

This hook will allow us to dynamically create a write call to our DAO's auction contract. Using user input values to create bid interactions on the contract.

We'll create a separate component that'll be rendered inside our `CurrentAuction` component that handles bidding functionality.
